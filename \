#include <iostream>
#include <map>
#include <set>
#include <random>

using namespace std;

struct comp {
	template<typename T>
	bool operator()(const T& l, const T& r) const {
		if(l.second != r.second) {
			return l.second > r.second;
		}

		return true;
	}
};

class Node {
	public:
		string name;
		map<Node*, double> transitions;	
		set<pair<Node*, double>, comp> organizedTransitions;

		Node(string nodeName) {
			name = nodeName;
		}

		bool checkTransitions() {
			double total = 0.0;

			map<Node*, double>::iterator it;

			for(it = transitions.begin(); it != transitions.end(); it++) {
				cout << name << "->" << it->first->name << ":" << it->second << endl;
				total += it->second;
			}

			cout << total << endl;
			return total == 1.0;
		}
};


int main() {
	srand(time(NULL));

	Node *nodeA = new Node("A");
	Node *nodeB = new Node("B");
	Node *nodeC = new Node("C");

	Node *nodeMap[] = {nodeA, nodeB, nodeC};
	int nodeMapSize = sizeof(nodeMap)/sizeof(nodeMap[0]);

	// test data
	nodeA->transitions.insert({nodeA, 0.1});
	nodeA->transitions.insert({nodeB, 0.7});
	nodeA->transitions.insert({nodeC, 0.2});
	nodeB->transitions.insert({nodeA, 0.6});
	nodeB->transitions.insert({nodeB, 0.3});
	nodeB->transitions.insert({nodeC, 0.1});
	nodeC->transitions.insert({nodeA, 0.79});
	nodeC->transitions.insert({nodeB, 0.2});
	nodeC->transitions.insert({nodeC, 0.01});

	Node *current = nodeA;

	// check transitions and sort
	for(int i = 0; i < nodeMapSize; i++) {
		if(nodeMap[i]->checkTransitions() != 1) {
			cout << nodeMap[i]->checkTransitions() << endl;
			cout << "ERROR: node " << nodeMap[i]->name << "'s transitions do not sum to 1.0." << endl;
			return 1;
		}

		// sort transitions by value
		nodeMap[i]->organizedTransitions = set<pair<Node*, double>, comp>(nodeMap[i]->transitions.begin(), nodeMap[i]->transitions.end());
	}
	//set<pair<Node*, double>, comp> setB(nodeB->transitions.begin(), nodeB->transitions.end());

	/*
	// https://stackoverflow.com/questions/2704521/generate-random-double-numbers-in-c
	double lowerBound = 0;
	double upperBound = 100;
	uniform_real_distribution<double> unif(lowerBound,upperBound);
	default_random_engine re;
	double randomDouble = unif(re);
	*/

	for(int step = 0; step < 100; step++) {
		// god FUCK floating point
		double randomDouble = ((double)rand() / (double)RAND_MAX);
		cout << current->name << ", " << randomDouble << endl;

		for(auto const &pair: current->organizedTransitions) {
			if(randomDouble >= pair.second) {
				current = pair.first;
				break;
			} else {
				current = pair.first;
			}
		}

		//cout << nodeA->checkTransitions() << endl;
	}

	for(int i = 0; i < nodeMapSize; i++) {
		delete nodeMap[i];
	}

	return 0;
}
